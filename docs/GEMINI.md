# Gemini 개발 가이드: 클린 아키텍처

이 문서는 프로젝트의 일관성 있는 아키텍처를 유지하기 위한 개발 가이드입니다. 모든 기능 개발 및 수정 작업 시 아래의 아키텍처 원칙을 반드시 준수합니다.

## 1. 백엔드 아키텍처 (BE-main)

### 요청 처리 및 데이터 흐름

모든 요청은 다음의 계층형 아키텍처를 따라 처리됩니다.

**`Router → Usecases → Service → Repository → Model`**

---

### 각 계층의 역할과 책임 (SoC: Separation of Concerns)

1.  **`Router` (API 계층 - `app/api/routers/`)**
    *   **책임**: HTTP 요청 수신 및 응답 반환 (통신 담당)
    *   **규칙**:
        *   클라이언트의 요청을 받는 유일한 진입점입니다.
        *   `schemas`를 사용해 요청 데이터를 검증합니다.
        *   비즈니스 로직을 포함하지 않습니다.
        *   해당하는 `Usecases`를 호출하고 결과를 받아 응답으로 변환합니다.

2.  **`Usecases` (유스케이스 계층 - `app/usecases/`)**
    *   **책임**: 특정 기능 시나리오의 흐름 조율 (Orchestration)
    *   **규칙**:
        *   하나의 기능(Use Case)을 완성하기 위해 필요한 여러 `Service`들을 순서에 맞게 호출합니다.
        *   애플리케이션의 고수준 정책과 흐름을 정의합니다.
        *   직접적인 데이터베이스 접근이나 복잡한 비즈니스 규칙 계산을 수행하지 않습니다.

3.  **`Service` (서비스 계층 - `app/services/`)**
    *   **책임**: 핵심 비즈니스 로직 수행
    *   **규칙**:
        *   재사용 가능한 비즈니스 규칙과 계산을 캡슐화합니다.
        *   데이터 처리가 필요할 경우 `Repository`에 요청합니다.
        *   HTTP 요청이나 데이터베이스 구현 기술에 대해 알지 못합니다.

4.  **`Repository` (리포지토리 계층 - `app/repositories/`)**
    *   **책임**: 데이터 영속성(Persistence) 관리 (데이터베이스 통신 전담)
    *   **규칙**:
        *   데이터베이스와의 모든 상호작용(CRUD)을 담당하는 유일한 계층입니다.
        *   `Model` 객체를 사용하여 ORM을 통해 쿼리를 실행합니다.
        *   `Service` 계층에 데이터베이스 구현 기술(e.g., PostgreSQL, SQLAlchemy)을 숨깁니다.

5.  **`Model` (모델 계층 - `app/models/`)**
    *   **책임**: 데이터 구조 정의
    *   **규칙**:
        *   데이터베이스 테이블의 스키마를 파이썬 클래스로 정의합니다.
        *   비즈니스 로직을 포함하지 않습니다.

---

**개발 프로세스:**
1.  기능 구현 전, 이 문서를 다시 확인하여 아키텍처를 숙지합니다.
2.  변경 사항은 항상 이 구조에 맞춰 각 계층에 적절히 분배하여 구현합니다.

---

## 2. 프론트엔드 분석 (Admin-FE)

### 개요
- **AI 기반 데이터 모니터링 및 제어를 위한 관리자 대시보드**
- 백엔드(`BE-main`)와 완벽하게 한 쌍을 이루는 시스템.
- **기술 스택**: Next.js(React), TypeScript, Tailwind CSS, Radix UI, Three.js

### 주요 기능

- **인증**: `/login` 페이지를 통한 사용자 로그인.
- **메인 대시보드**: `/dashboard`
  - 전체 시스템 현황 요약 및 3D 그래픽을 활용한 데이터 시각화.
- **핵심 관리 기능**:
  - `/dashboard/agent-network`: 에이전트 네트워크 관리 및 시각화.
  - `/dashboard/command-center`: 중앙 실시간 관제 및 명령.
  - `/dashboard/detection-settings`: AI 탐지 정책 설정 (백엔드 연동).
  - `/dashboard/intelligence`: 데이터 분석 및 리포팅.
  - `/dashboard/logs`: 시스템 및 탐지 로그 조회 (백엔드 연동).
  - `/dashboard/operations`: 시스템 운영 관리.
  - `/dashboard/systems`: 시스템 구성 요소 헬스체크 및 모니터링.

---

## 3. API 명세 (API Specification) 가이드

### 정의
API 명세는 프론트엔드와 백엔드 간의 통신 규칙을 정의한 **공식 계약서** 또는 **상세 설명서**입니다. 개발의 효율성을 높이고 오류를 줄이기 위한 필수적인 문서입니다.

### 필요성
- **독립적인 병렬 개발**: 명세를 기준으로 각자 개발을 진행하여 전체 개발 속도를 향상시킵니다.
- **모호함 제거**: 요청과 응답의 데이터 구조를 명확히 하여 통합 시 발생할 오류를 사전에 방지합니다.
- **자동화된 문서 및 테스트**: FastAPI의 Swagger UI처럼 코드를 기반으로 테스트 가능한 문서를 자동 생성할 수 있습니다.
- **원활한 협업**: 프로젝트의 통신 규약을 명확히 하여 모든 팀원이 동일한 이해를 바탕으로 협업할 수 있습니다.

### 필수 포함 요소
- **엔드포인트 (Endpoint)**: API 주소 (e.g., `/api/v1/logs`)
- **HTTP 메서드 (Method)**: 작업 종류 (`GET`, `POST`, `PUT`, `DELETE`)
- **요청 (Request)**:
  - **Header**: 인증 토큰 등
  - **Parameters**: Path, Query 등
  - **Body**: 전송할 데이터의 JSON 구조 (백엔드의 `schemas`와 일치)
- **응답 (Response)**:
  - **상태 코드 (Status Code)**: 처리 결과 (`200`, `404` 등)
  - **Body**: 반환될 데이터의 JSON 구조